<html>
<body>
    <script src="node_modules/cropperjs/dist/cropper.min.js"></script>
    <script src="node_modules/pica/dist/pica.min.js"></script>
    <script src="node_modules/rgbquant/src/rgbquant.js"></script>
    <script src="node_modules/jquery/dist/jquery.min.js"></script>
    <script src="node_modules/bootstrap-slider/dist/bootstrap-slider.min.js"></script>
    <!-- Wrap the image or canvas element with a block element (container) -->
    <link rel="stylesheet" href="node_modules/font-awesome/css/font-awesome.min.css" crossorigin="anonymous">
    <link rel="stylesheet" href="node_modules/bootstrap/dist/css/bootstrap.min.css" crossorigin="anonymous">
    <link rel="stylesheet" href="node_modules/cropperjs/dist/cropper.min.css">
    <link rel="stylesheet" href="node_modules/bootstrap-slider/dist/css/bootstrap-slider.min.css">
    <style type="text/css" media="screen">
body {
    background:#ddd;
}
img.crop {
    display: block;
    max-width: 100%;
}
.emuvideo {
    display: block;
    width: 40%;
    margin: auto;
    background: #000;
    pointer-events:auto;
}
</style>
<div class="container">
    <div class="row">
        <div class="col-md-6">
            <!--
            <img id="srcimage" src="node_modules/rgbquant/demo/img/chopsuey.jpg">
            -->
            <img class="crop" id="srcimage" src="../images/benbenn.jpg">
        </div>
        <div class="col-md-6">
            <canvas id="destcanvas" class="emuvideo"
                width="160" height="200" style="transform: scaleX(2.0) scaleY(1.0);"></canvas>
            <div class="ml-5 mt-3">
                <p>Diffuse:
                    <input type="range" id="diffuseSlider"
                        data-provide="slider"
                        data-slider-min="0"
                        data-slider-max="100"
                        data-slider-value="80"
                        /></p>
                <p>Noise:
                    <input type="range" id="noiseSlider"
                        data-provide="slider"
                        data-slider-min="0"
                        data-slider-max="10"
                        data-slider-value="0"
                        /></p>
                <p>
                    <input type="button" id="resetButton" value="Reset"></p>
            </div>
        </div>
    </div>
    <div class="row">
        <div class="col-md-6">
            <span id="cmdline"></span>
        </div>
    </div>
<canvas id="resizecanvas" width="160" height="200" style="display:none">
</div>

<script>
    function rnd(n) { return Math.floor(Math.random()*n); }
    function sqr(x) { return x*x; }

    var DITHER_TWOD = [[1, 0, 0.5], [0, 1, 0.5]];
    var DITHER_RIGHT = [[1, 0, 1.0]];
    var DITHER_DOWN = [[0, 1, 1.0]];
    var DITHER_DIAG = [[1, 1, 1.0]];
    var DITHER_FLOYD = [[1, 0, 7/16], [-1, 1, 3/16], [0, 1, 5/16], [1, 1, 1/16]];
    var DITHER_FALSEFLOYD = [[1, 0, 3/8], [0, 1, 3/8], [1, 1, 2/8]];
    var DITHER_ATKINSON = [[1, 0, 1/6], [2, 0, 1/6], [-1, 1, 1/6], [0, 1, 1/6], [1, 1, 1/6], [0, 2, 1/6]];
    var DITHER_SIERRA2 = [[1, 0, 4/16], [2, 0, 3/16], [-2, 1, 1/16], [-1, 1, 2/16], [0, 1, 3/16], [1, 1, 2/16], [2, 1, 1/16]];
    var DITHER_VDIAMOND = [[0, 1, 6/16], [-1, 1, 3/16], [1, 1, 3/16], [-2, 2, 1/16], [0, 2, 2/16], [2, 2, 1/16]];
    var DITHER_SIERRALITE = [[1, 0, 2/4], [-1, 1, 1/4], [0, 1, 1/4]];
    var DITHER_STUCKI =  [[1, 0, 8/42], [2, 0, 4/42], [-2, 1, 2/42], [1, -1, 4/42], [0, 1, 8/42], [1, 1, 4/42], [2, 1, 2/42], [-2, 2, 1/42], [-1, 2, 2/42], [0, 2, 4/42], [1, 2, 2/42], [2, 2, 1/42]];

    class DitheringCanvas {
        pal; // Uint32Array
        img; // Uint32Array
        ref; // Uint32Array
        alt; // Uint32Array
        err; // Uint16Array (n*3)
        indexed; // Uint8Array
        width; // integer
        tmp;
        tmp2;
        totalerror;
        besterror;
        changes;
        ghisto;
        noise = 20;
        diffuse = 0.8;
        ditherfn = DITHER_FLOYD;

        constructor(img, width, pal) {
            this.pal = new Uint32Array(pal);
            this.width = width;
            this.height = Math.floor(img.length / width);
            this.tmp = new Uint8ClampedArray(4);
            this.tmp2 = new Uint32Array(this.tmp.buffer);
            this.ref = new Uint32Array(img);
            this.reset();
        }
        reset() {
            this.indexed = new Uint8Array(this.ref.length);
            this.indexed.fill(0xff);
            this.ghisto = new Uint32Array(this.pal.length);
            this.img = new Uint32Array(this.ref);
            this.alt = new Uint32Array(this.ref);
            this.err = new Int16Array(this.ref.length * 3);
            this.totalerror = 0;
            this.besterror = 999999999;
            this.changes = 0;
        }
        init() {
        }
        update(offset) {
            var errofs = offset*3;
            var rgbref = this.ref[offset];
            // add cumulative error to pixel, clamp @ 0-255
            this.tmp[0] = (rgbref & 0xff) + this.err[errofs];
            this.tmp[1] = ((rgbref>>8) & 0xff) + this.err[errofs+1];
            this.tmp[2] = ((rgbref>>16) & 0xff) + this.err[errofs+2];
            // store the error-modified color
            this.alt[offset] = this.tmp2[0];
            // find closest palette color
            var palidx = this.getClosest(this.tmp2[0], this.getValidColors(offset));
            var rgbimg = this.pal[palidx];
            // compute error and distribute to neighbors
            var err = getRGBADiff(rgbref, rgbimg);
            for (var i=0; i<3; i++) {
                var k = (this.err[errofs+i] + err[i]) * this.diffuse;
                this.ditherfn.forEach((df) => {
                    this.err[errofs + i + (df[0] + df[1]*this.width)*3] += k * df[2];
                });
                this.err[errofs+i] = 0; // reset this pixel's error
            }
            // set new pixel rgb
            if (this.indexed[offset] != palidx) {
                this.indexed[offset] = palidx;
                this.ghisto[palidx]++;
                this.changes++;
            }
            this.img[offset] = rgbimg;
            //this.img[offset] = this.tmp2[0] | 0xff000000;
            // return error mag
            // TODO: perceptual error?
            var cumerr = Math.sqrt(sqr(err[0]) + sqr(err[1]) + sqr(err[2]));
            this.totalerror += cumerr;
            return cumerr;
        }
        getValidColors(offset) {
            return this.allColors;
        }
        getClosest(rgb, inds) {
            var best = 9999999;
            var bestidx = -1;
            for (var i=0; i<inds.length; i++) {
                var col = this.pal[inds[i]];
                var score = getRGBAErrorMag(rgb, col);
                if (score < best) {
                    best = score;
                    bestidx = inds[i];
                }
            }
            return bestidx;
        }
        addHisto(histo, rgb, inds) {
            var choices = [];
            for (var i=0; i<inds.length; i++) {
                var score = getRGBAErrorMag(rgb, this.pal[inds[i]]);
                histo[inds[i]] -= score;
            }
            return choices;
        }
    }
    class VDPMode2_Canvas extends DitheringCanvas {
        w=8;
        h=8;
        init() {
            this.params = new Uint8Array(40*200);
            this.allColors = [0,2,3,4,5,6,7,8,9,10,11,12,13,14,15];
            for (var i=0; i<this.params.length; i++) {
                this.guessParam(i);
            }
        }
        guessParam(p) {
            var offset = p*8;
            var colors = this.allColors;
            var histo = new Uint32Array(16);
            for (var i=0; i<8; i++) {
                var ind1 = this.getClosest(this.img[offset+i], colors);
                histo[ind1] += 100;
                // TODO: or ref?
                var ind2 = this.getClosest(this.alt[offset+i], colors.filter((c) => c != ind1));
                histo[ind2] += 1 + this.noise;
            }
            var choices = getChoices(histo);
            var ind1 = choices[0].ind;
            var ind2 = choices[1].ind;
            if (ind1 > ind2) {
                var tmp = ind1;
                ind1 = ind2;
                ind2 = tmp;
            }
            this.params[p] = ind1 + (ind2 << 4);
            //if (offset < 100) console.log(p, choices);
        }
        getValidColors(offset) {
            var i = Math.floor(offset / 8);
            var c1 = this.params[i] & 0xf;
            var c2 = (this.params[i]>>4) & 0xf;
            return [c1, c2];
        }
        commit() {
            // skip params @ random
            for (var i=0; i<this.params.length; i+=rnd(2)+1) {
                this.guessParam(i);
            }
        }
        iterate() {
            this.totalerror = 0;
            this.changes = 0;
            for (var i=0; i<this.img.length; i++) {
                this.update(i);
            }
            this.commit();
            //console.log(this.totalerror);
        }
    }
    class ZXSpectrum_Canvas extends VDPMode2_Canvas {
        w=8;
        h=8;
        init() {
            this.ncols = this.width / this.w;
            this.nrows = this.height / this.h;
            this.params = new Uint8Array(this.ncols * this.nrows);
            this.allColors = [0,1,2,3,4,5,6,7,9,10,11,12,13,14,15];
            for (var i=0; i<this.params.length; i++) {
                this.guessParam(i);
            }
        }
        getValidColors(offset) {
            var col = Math.floor(offset / this.w) % this.ncols;
            var row = Math.floor(offset / (this.width * this.h));
            var i = col + row*this.ncols;
            var c1 = this.params[i] & 0xf;
            var c2 = (this.params[i]>>4) & 0xf;
            return [c1, c2];
        }
        guessParam(p) {
            var col = p % this.ncols;
            var row = Math.floor(p / this.ncols);
            var offset = col*this.w + row*(this.width*this.h);
            var colors = this.allColors;
            var histo = new Uint32Array(16);
            for (var i=0; i<64; i++) {
                var ind1 = this.getClosest(this.img[offset+i], colors);
                histo[ind1] += 100;
                var ind2 = this.getClosest(this.ref[offset+i], colors.filter((c) => c != ind1));
                histo[ind2] += 1 + this.noise;
                if ((i&7)==7) offset += this.width-8; // TODO: this.w
            }
            var choices = getChoices(histo);
            var ind1 = choices[0].ind;
            var ind2 = choices[1].ind;
            if (ind1 > ind2) {
                var tmp = ind1;
                ind1 = ind2;
                ind2 = tmp;
            }
            this.params[p] = ind1 + (ind2 << 4);
            //if (offset < 100) console.log(p, choices);
        }
    }
    class VICII_Multi_Canvas extends VDPMode2_Canvas {
        w=4;
        h=8;
        init() {
            this.bgcolor = 0;
            this.ghisto.fill(0);
            this.params = new Uint16Array(this.width/this.w * this.height/this.h);
            this.allColors = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];
            for (var i=0; i<this.params.length; i++) {
                this.guessParam(i);
                this.bgcolor = getChoices(this.ghisto)[0].ind;
            }
        }
        getValidColors(offset) {
            var ncols = this.width / this.w;
            var col = Math.floor(offset / this.w) % ncols;
            var row = Math.floor(offset / (this.width*this.h));
            var i = col + row*ncols;
            var c1 = this.params[i] & 0xf;
            var c2 = (this.params[i] >> 4) & 0xf;
            var c3 = (this.params[i] >> 8) & 0xf;
            return [this.bgcolor, c1, c2, c3];
        }
        guessParam(p) {
            var ncols = this.width / this.w;
            var col = p % ncols;
            var row = Math.floor(p / ncols);
            var offset = col*this.w + row*this.width*this.h;
            var colors = this.allColors.filter((ind) => ind != this.bgcolor);
            // rank all colors
            var histo = new Uint32Array(16);
            for (var i=0; i<64; i++) {
                // get current color (or reference for 1st time)
                var refrgb = this.img[offset+i];
                var ind1 = this.getClosest(refrgb, colors);
                histo[ind1] += 100;
                // get error color (TODO: why alt not img like 2-color kernels?)
                var rgbcomp = this.alt[offset+i];
                var ind2 = this.getClosest(rgbcomp, colors);
                histo[ind2] += 1 + this.noise;
                if ((i&7)==7) offset += this.width-8;
            }
            var choices = getChoices(histo);
            var ind1 = choices[0].ind;
            var ind2 = choices[1] && choices[1].ind;
            var ind3 = choices[2] && choices[2].ind;
            this.ghisto[ind1]++;
            /*
            ind1 = 3;
            ind2 = 4;
            ind3 = 7;
            */
            this.params[p] = ind1 + (ind2<<4) + (ind3<<8);
            //if (offset < 100) console.log(p, choices);
        }
    }
    class VICII_320_Canvas extends VICII_Multi_Canvas {
        w=8;
        init() {
            super.init();
        }
        getValidColors(offset) {
            // just take fg/bg
            return super.getValidColors(offset).slice(1,3);
        }
    }
    function getRGBADiff(rgbref, rgbimg) {
        var err = [0,0,0];
        for (var i=0; i<3; i++) {
            var d = (rgbref & 0xff) - (rgbimg & 0xff);
            err[i] = d;
            rgbref >>= 8;
            rgbimg >>= 8;
        }
        return err;
    }
    getRGBAErrorMag = getRGBAErrorPerceptual;
    function getRGBAErrorAbsolute(rgbref, rgbimg) {
        var mag = 0;
        for (var i=0; i<3; i++) {
            var d = (rgbref & 0xff) - (rgbimg & 0xff);
            mag += sqr(d);
            rgbref >>= 8;
            rgbimg >>= 8;
        }
        return Math.sqrt(mag);
    }
    function getRGBAErrorHue(rgbref, rgbimg) {
        var r1 = ((rgbref>>0) & 0xff);
        var g1 = ((rgbref>>8) & 0xff);
        var b1 = ((rgbref>>16) & 0xff);
        var r2 = ((rgbimg>>0) & 0xff);
        var g2 = ((rgbimg>>8) & 0xff);
        var b2 = ((rgbimg>>16) & 0xff);
        //var mag1 = Math.sqrt(sqr(r1-r2) + sqr(g1-g2) + sqr(b1-b2));
        var avg1 = (r1+g1+b1)/3+1;
        var avg2 = (r2+g2+b2)/3+1;
        r1 /= avg1;
        g1 /= avg1;
        b1 /= avg1;
        r2 /= avg2;
        g2 /= avg2;
        b2 /= avg2;
        var mag2 = Math.sqrt(sqr(r1-r2) + sqr(g1-g2) + sqr(b1-b2));
        return mag2;
    }
    function getRGBAErrorPerceptual(rgbref, rgbimg) {
        var r1 = ((rgbref>>0) & 0xff);
        var g1 = ((rgbref>>8) & 0xff);
        var b1 = ((rgbref>>16) & 0xff);
        var r2 = ((rgbimg>>0) & 0xff);
        var g2 = ((rgbimg>>8) & 0xff);
        var b2 = ((rgbimg>>16) & 0xff);
        var rmean = (r1 + r2) / 2;
        var r = r1 - r2;
        var g = g1 - g2;
        var b = b1 - b2;
        return Math.sqrt((((512+rmean)*r*r)/256) + 4*g*g + (((767-rmean)*b*b)/256));
    }
    function getRGBAErrorMax(rgbref, rgbimg) {
        var r1 = ((rgbref>>0) & 0xff);
        var g1 = ((rgbref>>8) & 0xff);
        var b1 = ((rgbref>>16) & 0xff);
        var r2 = ((rgbimg>>0) & 0xff);
        var g2 = ((rgbimg>>8) & 0xff);
        var b2 = ((rgbimg>>16) & 0xff);
        return Math.max(Math.abs(r1-r2), Math.abs(g1-g2), Math.abs(b1-b2));
    }
    function getRGBAErrorArr(a,b) {
        var err = [0,0,0];
        for (var i=0; i<3; i++) {
            err[i] = ((a & 0xff) - (b & 0xff));
            a >>= 8;
            b >>= 8;
        }
        return err;
    }
    // byte order reversed in this app
    function RGBA(r,g,b) {
        return ((r&0xff)<<16) | ((g&0xff)<<8) | ((b&0xff)<<0) | 0xff000000;
    }
    const VIC_NTSC_RGB = [
        0x000000,
        0xFFFFFF,
        RGBA(163,64,69),
        RGBA(125,235,228),
        RGBA(174,70,186),
        RGBA(94,202,84),
        RGBA(60,57,200),
        RGBA(255,255,111),
        RGBA(174,96,47),
        RGBA(110,73,0),
        RGBA(232,122,128),
        RGBA(92,92,92),
        RGBA(143,143,143),
        RGBA(179,255,167),
        RGBA(129,126,255),
        RGBA(199,199,199)
    ];
    const TMS9918_RGB = [
        RGBA(0,0,0),
        RGBA(0,0,0),
        RGBA(33,200,66),
        RGBA(94,220,120),
        RGBA(84,85,237),
        RGBA(125,118,252),
        RGBA(212,82,77),
        RGBA(66,235,245),
        RGBA(252,85,84),
        RGBA(255,121,120),
        RGBA(212,193,84),
        RGBA(230,206,128),
        RGBA(33,176,59),
        RGBA(201,91,186),
        RGBA(204,204,204),
        RGBA(255,255,255)
    ];
    const ZXSPECTRUM_RGB = [
        0x000000,
        0x0000d7,
        0xd70000,
        0xd700d7,
        0x00d700,
        0x00d7d7,
        0xd7d700,
        0xd7d7d7,
        0x000000,
        0x0000ff,
        0xff0000,
        0xff00ff,
        0x00ff00,
        0x00ffff,
        0xffff00,
        0xffffff,
    ];
    const AP2HIRES_RGB = [
        RGBA(0, 0, 0),
        RGBA(255, 68, 253),
        RGBA(20, 245, 60),
        RGBA(20, 207, 253),
        RGBA(255, 106, 60),
        RGBA(255, 255, 255)
    ];
    function getHistogram(inds) {
        var histo = new Uint8Array(256);
        inds.forEach((x) => histo[x]++);
        return getChoices(histo);
    }
    function getChoices(histo) {
        var choices = [];
        for (var i=0; i<histo.length; i++) {
            if (histo[i]) choices.push({count:histo[i], ind:i});
        }
        choices.sort((a,b) => b.count - a.count);
        return choices;
    }
    function rgb2tuple(arr) {
        return arr.map((x) => [(x>>16) & 0xff, (x>>8) & 0xff, (x>>0) & 0xff]);
    }
    function drawPixels(quant, dest, inds) {
        //console.log(quant, dest, inds);
        var ctx = dest.getContext('2d');
        var imageData = ctx.createImageData(dest.width, dest.height);
        var datau32 = new Uint32Array(imageData.data.buffer);
        for (var i=0; i<inds.length; i++) {
            datau32[i] = quant.idxi32[inds[i]];
        }
        ctx.putImageData(imageData, 0, 0);
    }
    function drawRGBA(dest, arr) {
        var ctx = dest.getContext('2d');
        var imageData = ctx.createImageData(dest.width, dest.height);
        var datau32 = new Uint32Array(imageData.data.buffer);
        datau32.set(arr);
        ctx.putImageData(imageData, 0, 0);
    }
    function getCanvasImageData(canvas) {
        return new Uint32Array(canvas.getContext('2d').getImageData(0,0,canvas.width,canvas.height).data.buffer);
    }
    function convertImage() {
        pica().resize(cropper.getCroppedCanvas(), resize, {
            /*
            unsharpAmount: 50,
            unsharpRadius: 0.5,
            unsharpThreshold: 2
            */
        }).then(() => {
            dithcanv = null;
            updateImage();
        });
    }
    var dithcanv = null;
    function updateImage() {
        const quant = new RgbQuant(quantopts);
        // TODO: bgcolor
        //quant.sample(resize);
        //quant.palette(false, true);
        if (dithcanv == null) {
            dithcanv = new VICII_Multi_Canvas(getCanvasImageData(resize), dest.width, quant.idxi32);
            dithcanv.noise = 1 << document.getElementById('noiseSlider').value;
            dithcanv.diffuse = document.getElementById('diffuseSlider').value / 100;
            dithcanv.init();
        }
        //dithcanv.noise = 1 << document.getElementById('noiseSlider').value;
        dithcanv.diffuse = document.getElementById('diffuseSlider').value / 100;
        dithcanv.iterate();
        console.log(dithcanv.changes, dithcanv.totalerror, dithcanv.bgcolor);
        drawRGBA(dest, dithcanv.img);
    }
    function resetImage() {
        dithcanv = null;
        updateImage();
    }
    const quantopts = {
        palette:rgb2tuple(VIC_NTSC_RGB),
        reIndex:true,
        colors:16,
    };
    const image = document.getElementById('srcimage');
    const resize = document.getElementById('resizecanvas');
    const dest = document.getElementById('destcanvas');
    const cmdline = document.getElementById('cmdline');
    const cropper = new Cropper(image, {
      //aspectRatio: 16 / 9,
      crop(event) {
          convertImage();
      },
    });
    function timerUpdate() {
        setTimeout(timerUpdate, 100);
        if (dithcanv == null || dithcanv.changes > 0) {
            updateImage();
            dithcanv.noise >>= 1;
        }
    }
    timerUpdate();
    dest.onmousedown = (e) => {
        updateImage();
    }
    $("#diffuseSlider").on('change', updateImage);
    $("#noiseSlider").on('change', resetImage);
    $("#resetButton").on('click', resetImage);
</script>
    
</body>
</html>
